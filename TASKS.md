# BFL-Optimistic-Poison-Defend 測試導向實作任務清單

本任務清單採用測試驅動開發 (TDD) 方法，確保每個功能區塊可獨立完成並通過測試。專案使用 Foundry 作為智能合約開發框架。

## 1. 開發環境設置 [優先度: 高]
- [x] 安裝和配置 Foundry
  - [x] 撰寫測試：驗證環境設置正確
  - [x] 實作：安裝 Foundry 並設置專案結構
  - [x] 測試通過確認

- [x] 設置 Arbitrum 開發環境
  - [x] 撰寫測試：確認能夠連接到 Arbitrum 測試網
  - [x] 實作：配置 Foundry 以支援 Arbitrum 網絡
  - [x] 測試通過確認

- [x] 創建基本專案結構
  - [x] 撰寫測試：驗證檔案結構符合 Foundry 標準
  - [x] 實作：建立 src/、test/ 和 script/ 目錄
  - [x] 測試通過確認

## 2. 智能合約開發 (單一合約架構)
### 2.1 基礎設施 [優先度: 高]
- [x] 定義基本資料結構與狀態變數
  - [x] 撰寫測試：驗證狀態變數初始化 (`FederatedLearning.t.sol`)
  - [x] 實作：定義任務、輪次、客戶端、更新等結構 (`FederatedLearning.sol`)
  - [x] 測試通過確認：使用 `forge test`

- [x] 實作權限管理系統
  - [x] 撰寫測試：驗證只有授權角色可執行受限功能
  - [x] 實作：定義權限修飾器並整合 OpenZeppelin 的 Access Control
  - [x] 測試通過確認：使用 `forge test`

### 2.2 任務管理 [優先度: 高]
- [x] 任務建立功能
  - [x] 撰寫測試：驗證任務成功建立與參數儲存
  - [x] 實作：`createTask` 函數，包含參數驗證
  - [x] 測試通過確認：使用 `forge test`

- [x] 任務狀態管理
  - [x] 撰寫測試：驗證任務狀態轉換
  - [x] 實作：任務狀態更新邏輯
  - [x] 測試通過確認：使用 `forge test`

- [x] 任務完成邏輯
  - [x] 撰寫測試：驗證任務完成條件與結果
  - [x] 實作：`completeTask` 函數
  - [x] 測試通過確認：使用 `forge test`

### 2.3 輪次管理 [優先度: 高]
- [x] 輪次初始化
  - [x] 撰寫測試：驗證輪次正確初始化
  - [x] 實作：`startRound` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 輪次狀態追蹤
  - [x] 撰寫測試：驗證輪次狀態轉換
  - [x] 實作：輪次狀態更新邏輯
  - [x] 測試通過確認：使用 `forge test`

- [x] 輪次完成邏輯
  - [x] 撰寫測試：驗證輪次完成條件與結果
  - [x] 實作：`completeRound` 函數
  - [x] 測試通過確認：使用 `forge test`

### 2.4 客戶端管理 [優先度: 中]
- [x] 客戶端註冊機制
  - [x] 撰寫測試：驗證客戶端註冊結果
  - [x] 實作：`registerClient` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 客戶端選擇邏輯
  - [x] 撰寫測試：驗證客戶端選擇算法
  - [x] 實作：`selectClients` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 客戶端貢獻追蹤
  - [x] 撰寫測試：驗證貢獻分數計算
  - [x] 實作：`updateContribution` 函數
  - [x] 測試通過確認：使用 `forge test`

### 2.5 Krum 防禦機制 [優先度: 高]
- [x] 創建 Krum 演算法庫
  - [x] 撰寫測試：驗證庫合約的基本方法
  - [x] 實作：`KrumDefense.sol` 庫合約
  - [x] 測試通過確認：使用 `forge test`

- [x] 模型更新提交
  - [x] 撰寫測試：驗證更新提交流程
  - [x] 實作：`submitModelUpdate` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 更新距離計算
  - [x] 撰寫測試：驗證距離計算正確性
  - [x] 實作：`computeDistances` 函數
  - [x] 測試通過確認：使用模糊測試 (`forge test --fuzz-runs 100`)

- [x] Krum 選擇算法
  - [x] 撰寫測試：驗證 Krum 算法在預設情況下選擇正確
  - [x] 實作：`executeKrum` 函數
  - [x] 測試通過確認：使用已知結果的測試案例

- [ ] 最佳更新選擇
  - [x] 撰寫測試：驗證在混合更新中能夠選出非惡意的更新
  - [x] 實作：`applyKrum` 函數以整合距離計算和選擇
  - [ ] 測試通過確認：使用惡意/非惡意混合的測試案例 (Krum 選擇算法待優化)

### 2.6 獎勵系統 [優先度: 低]
- [x] 獎勵計算邏輯
  - [x] 撰寫測試：驗證獎勵計算正確性
  - [x] 實作：`calculateRewards` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 獎勵分發
  - [x] 撰寫測試：驗證獎勵分發流程
  - [x] 實作：`distributeRewards` 函數
  - [x] 測試通過確認：使用 `forge test`

## 3. IPFS 整合
### 3.1 模型儲存 [優先度: 高]
- [x] 更新 IPFS 連接器以支援 Foundry 輸出
  - [x] 撰寫測試：驗證連接器可正確讀取 Foundry 生成的合約地址和 ABI
  - [x] 實作：更新 `ipfs_connector.py`
  - [x] 測試通過確認：使用 Python 單元測試

- [x] 模型上傳功能
  - [x] 撰寫測試：驗證模型成功上傳到 IPFS
  - [x] 實作：優化 `upload_model` 函數
  - [x] 測試通過確認：使用小型測試模型

- [x] 模型下載功能
  - [x] 撰寫測試：驗證模型成功從 IPFS 下載
  - [x] 實作：優化 `download_model` 函數
  - [x] 測試通過確認：驗證下載模型與上傳模型一致

### 3.2 更新管理 [優先度: 中]
- [x] 更新儲存功能
  - [x] 撰寫測試：驗證模型更新成功儲存
  - [x] 實作：`store_update` 函數
  - [x] 測試通過確認：使用多個測試更新

- [x] 批次操作
  - [x] 撰寫測試：驗證批次下載與處理
  - [x] 實作：`batch_download` 函數
  - [x] 測試通過確認：使用多個更新測試批次處理

## 4. 區塊鏈連接器增強
### 4.1 Arbitrum 整合 [優先度: 高]
- [x] 更新區塊鏈連接器以支援 Foundry 輸出
  - [x] 撰寫測試：驗證連接器可正確讀取 Foundry 生成的合約地址和 ABI
  - [x] 實作：更新 `blockchain_connector.py`
  - [x] 測試通過確認：使用 Python 單元測試

- [x] Arbitrum 連接設定
  - [x] 撰寫測試：驗證成功連接到 Arbitrum 測試網
  - [x] 實作：調整連接邏輯支援 Arbitrum
  - [x] 測試通過確認：連接參數與狀態檢查

- [ ] Gas 優化
  - [ ] 撰寫測試：比較優化前後的 gas 用量
  - [ ] 實作：gas 估算和優化邏輯
  - [ ] 測試通過確認：使用 `forge gas-report`

### 4.2 交易管理 [優先度: 中]
- [x] 交易提交與監控
  - [x] 撰寫測試：驗證交易提交與確認流程
  - [x] 實作：`transaction_lifecycle` 函數
  - [x] 測試通過確認：交易狀態追蹤

- [ ] 交易重試邏輯
  - [ ] 撰寫測試：模擬交易失敗並驗證重試機制
  - [ ] 實作：`retry_transaction` 函數
  - [ ] 測試通過確認：測試不同失敗情境

### 4.3 事件處理 [優先度: 中]
- [ ] 事件監聽機制
  - [ ] 撰寫測試：驗證事件訂閱與接收
  - [ ] 實作：`handle_events` 函數
  - [ ] 測試通過確認：模擬事件觸發和處理

- [ ] 事件驅動動作
  - [ ] 撰寫測試：驗證特定事件觸發預期動作
  - [ ] 實作：事件處理回調系統
  - [ ] 測試通過確認：事件鏈反應測試

## 5. 聯邦學習核心
### 5.1 Flower 伺服器 [優先度: 高]
- [ ] 更新伺服器以支援 Foundry 部署的合約
  - [ ] 撰寫測試：驗證伺服器可正確連接到 Foundry 部署的合約
  - [ ] 實作：更新伺服器代碼
  - [ ] 測試通過確認：連接和交互測試

- [ ] 任務初始化與配置
  - [ ] 撰寫測試：驗證伺服器配置與任務設定
  - [ ] 實作：FLServer 類別初始化
  - [ ] 測試通過確認：配置參數檢查

- [ ] 客戶端選擇策略
  - [ ] 撰寫測試：驗證客戶端選擇邏輯
  - [ ] 實作：`client_selection_strategy`
  - [ ] 測試通過確認：選擇結果驗證

### 5.2 模型管理 [優先度: 高]
- [ ] 全局模型處理
  - [ ] 撰寫測試：驗證全局模型初始化與更新
  - [ ] 實作：`manage_global_model` 函數
  - [ ] 測試通過確認：模型狀態檢查

- [ ] 模型聚合
  - [ ] 撰寫測試：驗證不同策略下的聚合結果
  - [ ] 實作：`aggregate_updates` 函數
  - [ ] 測試通過確認：使用已知結果的測試案例

- [ ] 模型評估
  - [ ] 撰寫測試：驗證評估指標計算
  - [ ] 實作：`evaluate_model` 函數
  - [ ] 測試通過確認：預定義模型評估

### 5.3 Flower 客戶端 [優先度: 高]
- [ ] 更新客戶端以支援 Foundry 部署的合約
  - [ ] 撰寫測試：驗證客戶端可正確連接到 Foundry 部署的合約
  - [ ] 實作：更新客戶端代碼
  - [ ] 測試通過確認：連接和交互測試

- [ ] 本地訓練邏輯
  - [ ] 撰寫測試：驗證本地訓練流程與結果
  - [ ] 實作：`train_locally` 函數
  - [ ] 測試通過確認：使用小型測試數據集

- [ ] 模型更新生成
  - [ ] 撰寫測試：驗證更新格式與結構
  - [ ] 實作：`generate_update` 函數
  - [ ] 測試通過確認：更新結構驗證

## 6. 防禦機制整合
### 6.1 Krum 客戶端策略 [優先度: 高]
- [ ] Krum 策略類別
  - [ ] 撰寫測試：驗證策略初始化與配置
  - [ ] 實作：KrumStrategy 類別
  - [ ] 測試通過確認：配置參數檢查

- [ ] 距離計算實作
  - [ ] 撰寫測試：驗證不同模型間距離計算
  - [ ] 實作：`compute_distances` 函數
  - [ ] 測試通過確認：使用已知向量對

### 6.2 整合測試 [優先度: 高]
- [ ] 端到端防禦測試
  - [ ] 撰寫測試：模擬真實訓練過程
  - [ ] 實作：orchestrator 模組整合所有元件
  - [ ] 測試通過確認：使用 Foundry forge 腳本模擬完整流程

- [ ] 防禦效果評估
  - [ ] 撰寫測試：比較有無防禦下的模型質量
  - [ ] 實作：`defense_evaluation` 函數
  - [ ] 測試通過確認：指標比較

## 7. 攻擊模擬與測試
### 7.1 惡意客戶端模擬 [優先度: 中]
- [ ] 標籤翻轉攻擊
  - [ ] 撰寫測試：驗證攻擊實作與效果
  - [ ] 實作：LabelFlippingAttack 類別
  - [ ] 測試通過確認：檢查產生的惡意更新

- [ ] 模型替換攻擊
  - [ ] 撰寫測試：驗證攻擊實作與效果
  - [ ] 實作：ModelReplacementAttack 類別
  - [ ] 測試通過確認：檢查產生的惡意更新

- [ ] 拜占庭行為
  - [ ] 撰寫測試：驗證不一致行為
  - [ ] 實作：ByzantineClient 類別
  - [ ] 測試通過確認：檢查隨機行為模式

### 7.2 攻擊成效評估 [優先度: 中]
- [ ] 無防禦下的攻擊測試
  - [ ] 撰寫測試：衡量攻擊對模型的影響
  - [ ] 實作：`measure_attack_impact` 函數
  - [ ] 測試通過確認：確認攻擊能成功影響未防禦模型

- [ ] 有防禦下的攻擊測試
  - [ ] 撰寫測試：衡量防禦有效性
  - [ ] 實作：`measure_defense_effectiveness` 函數
  - [ ] 測試通過確認：驗證防禦能抵抗攻擊

## 8. 部署與評估
### 8.1 Arbitrum 部署 [優先度: 中]
- [x] 開發部署腳本
  - [x] 撰寫測試：驗證部署流程
  - [x] 實作：`Deploy.s.sol` 腳本
  - [x] 測試通過確認：使用 `forge script`

- [ ] 部署到 Arbitrum Sepolia 測試網
  - [ ] 撰寫測試：驗證合約在測試網正確運行
  - [ ] 實作：使用 `forge script` 部署
  - [ ] 測試通過確認：合約功能驗證

- [ ] Gas 分析
  - [ ] 撰寫測試：記錄不同操作的 gas 用量
  - [ ] 實作：詳細的 gas 使用報告
  - [ ] 測試通過確認：使用 `forge gas-report`

### 8.2 性能評估 [優先度: 低]
- [ ] 系統吞吐量測試
  - [ ] 撰寫測試：衡量系統處理更新的能力
  - [ ] 實作：`throughput_test` 工具
  - [ ] 測試通過確認：不同規模下的測試

- [ ] 可擴展性評估
  - [ ] 撰寫測試：測試不同規模下系統表現
  - [ ] 實作：`scalability_evaluation` 函數
  - [ ] 測試通過確認：不同客戶端數量下的性能

### 8.3 結果視覺化 [優先度: 低]
- [ ] 實驗結果圖表
  - [ ] 撰寫測試：驗證視覺化輸出
  - [ ] 實作：`generate_charts` 工具
  - [ ] 測試通過確認：產生預期圖表

- [ ] 互動式儀表板
  - [ ] 撰寫測試：驗證儀表板功能
  - [ ] 實作：`dashboard` 模組
  - [ ] 測試通過確認：互動功能測試

## 9. 文檔與代碼質量
### 9.1 智能合約文檔 [優先度: 中]
- [x] 合約 NatSpec 文檔
  - [x] 撰寫所有公開函數的 NatSpec 註釋
  - [x] 生成合約文檔
  - [x] 驗證文檔完整性

- [ ] 開發者指南
  - [ ] 撰寫合約整合指南
  - [ ] 記錄常見錯誤和解決方案
  - [ ] 製作合約 API 參考

### 9.2 Python 代碼質量 [優先度: 中]
- [ ] 代碼格式化
  - [ ] 使用 Black 和 isort 格式化代碼
  - [ ] 設定 pre-commit 鉤子

- [ ] 類型提示與文檔
  - [ ] 為所有 Python 函數添加類型提示
  - [ ] 撰寫詳細的函數文檔字符串
  - [ ] 生成 API 文檔

- [ ] 單元測試覆蓋
  - [ ] 提高單元測試覆蓋率至 80%+
  - [ ] 實現模擬對象以測試外部依賴

## 測試環境設置
- [x] 設置 Arbitrum Sepolia 測試網絡連接
  - [x] 取得 RPC 端點
  - [x] 配置 Foundry 以連接測試網

- [x] 設置本地 IPFS 節點
  - [x] 安裝和配置 IPFS
  - [x] 測試連接性能

- [ ] 建立模擬訓練數據集
  - [ ] 生成合成數據
  - [ ] 製作測試用的假模型

- [ ] 設置 CI/CD 流程
  - [ ] 配置 GitHub Actions
  - [ ] 實現自動化測試
  - [ ] 設置部署流程

## 依賴關係
- 開發環境設置 → 智能合約開發 → 區塊鏈連接器增強 → 部署與評估
- 智能合約基礎設施 → 任務管理 → 輪次管理 → Krum 防禦機制
- IPFS 整合 → 聯邦學習核心
- 聯邦學習核心 → 防禦機制整合
- 惡意客戶端模擬 → 攻擊成效評估

## 階段性交付計劃
### 階段 1 (2 週) [進行中]
- [x] 完成開發環境設置
- [x] 完成智能合約基礎設施和任務管理
- [x] 完成 IPFS 模型儲存功能
- [x] 完成 Arbitrum 連接設定
- [x] 完成基本測試環境設置

### 階段 2 (2 週) [即將開始]
- [x] 完成輪次管理和客戶端管理
- [x] 完成 Krum 防禦機制合約部分
- [x] 完成區塊鏈交易和事件處理
- [ ] 開始 Flower 伺服器和客戶端實作

### 階段 3 (2 週)
- [ ] 完成 Flower 伺服器和客戶端
- [ ] 完成 Krum 防禦策略整合
- [ ] 實作並測試惡意客戶端攻擊
- [ ] 開始防禦效果評估

### 階段 4 (2 週)
- [ ] 完成攻擊模擬和防禦效果評估
- [ ] 完成 Arbitrum 部署和 Gas 分析
- [ ] 完成性能評估和視覺化
- [ ] 整合所有組件並進行最終測試

## 執行注意事項
1. 每個任務都遵循 "先測試，後實作" 的原則
2. 每個功能區塊必須有獨立測試並通過才能視為完成
3. 優先完成高優先度任務
4. 定期進行整合測試確保各部分協同工作
5. 使用 Foundry 的 forge 命令運行測試和部署
6. 在每個階段結束時進行代碼審查和重構