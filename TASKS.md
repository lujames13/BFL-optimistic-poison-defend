# BFL-Optimistic-Poison-Defend 測試導向實作任務清單

本任務清單採用測試驅動開發 (TDD) 方法，確保每個功能區塊可獨立完成並通過測試。專案使用 Foundry 作為智能合約開發框架。

## 1. 開發環境設置 [優先度: 高]

- [x] 安裝和配置 Foundry

  - [x] 撰寫測試：驗證環境設置正確
  - [x] 實作：安裝 Foundry 並設置專案結構
  - [x] 測試通過確認

- [x] 設置 Arbitrum 開發環境

  - [x] 撰寫測試：確認能夠連接到 Arbitrum 測試網
  - [x] 實作：配置 Foundry 以支援 Arbitrum 網絡
  - [x] 測試通過確認

- [x] 創建基本專案結構
  - [x] 撰寫測試：驗證檔案結構符合 Foundry 標準
  - [x] 實作：建立 src/、test/ 和 script/ 目錄
  - [x] 測試通過確認

## 2. 智能合約開發 (單一合約架構)

### 2.1 基礎設施 [優先度: 高]

- [x] 定義基本資料結構與狀態變數

  - [x] 撰寫測試：驗證狀態變數初始化 (`FederatedLearning.t.sol`)
  - [x] 實作：定義任務、輪次、客戶端、更新等結構 (`FederatedLearning.sol`)
  - [x] 測試通過確認：使用 `forge test`

- [x] 實作權限管理系統
  - [x] 撰寫測試：驗證只有授權角色可執行受限功能
  - [x] 實作：定義權限修飾器並整合 OpenZeppelin 的 Access Control
  - [x] 測試通過確認：使用 `forge test`

### 2.2 任務管理 [優先度: 高]

- [x] 任務建立功能

  - [x] 撰寫測試：驗證任務成功建立與參數儲存
  - [x] 實作：`createTask` 函數，包含參數驗證
  - [x] 測試通過確認：使用 `forge test`

- [x] 任務狀態管理

  - [x] 撰寫測試：驗證任務狀態轉換
  - [x] 實作：任務狀態更新邏輯
  - [x] 測試通過確認：使用 `forge test`

- [x] 任務完成邏輯
  - [x] 撰寫測試：驗證任務完成條件與結果
  - [x] 實作：`completeTask` 函數
  - [x] 測試通過確認：使用 `forge test`

### 2.3 輪次管理 [優先度: 高]

- [x] 輪次初始化

  - [x] 撰寫測試：驗證輪次正確初始化
  - [x] 實作：`startRound` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 輪次狀態追蹤

  - [x] 撰寫測試：驗證輪次狀態轉換
  - [x] 實作：輪次狀態更新邏輯
  - [x] 測試通過確認：使用 `forge test`

- [x] 輪次完成邏輯
  - [x] 撰寫測試：驗證輪次完成條件與結果
  - [x] 實作：`completeRound` 函數
  - [x] 測試通過確認：使用 `forge test`

### 2.4 客戶端管理 [優先度: 中]

- [x] 客戶端註冊機制

  - [x] 撰寫測試：驗證客戶端註冊結果
  - [x] 實作：`registerClient` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 客戶端選擇邏輯

  - [x] 撰寫測試：驗證客戶端選擇算法
  - [x] 實作：`selectClients` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 客戶端貢獻追蹤
  - [x] 撰寫測試：驗證貢獻分數計算
  - [x] 實作：`updateContribution` 函數
  - [x] 測試通過確認：使用 `forge test`

### 2.5 Krum 防禦機制基礎接口 [優先度: 高]

- [x] 創建 Krum 介面

  - [x] 撰寫測試：驗證介面合約的基本方法
  - [x] 實作：`KrumDefense.sol` 介面合約
  - [x] 測試通過確認：使用 `forge test`

- [x] 模型更新提交

  - [x] 撰寫測試：驗證更新提交流程
  - [x] 實作：`submitModelUpdate` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 更新接收與存儲

  - [x] 撰寫測試：驗證更新正確存儲
  - [x] 實作：更新存儲結構和邏輯
  - [x] 測試通過確認：使用 `forge test`

- [x] Krum 結果接收

  - [x] 撰寫測試：驗證 Krum 結果接收與處理
  - [x] 實作：`receiveKrumResult` 函數
  - [x] 測試通過確認：使用已知結果的測試案例

### 2.6 獎勵系統 [優先度: 低]

- [x] 獎勵計算邏輯

  - [x] 撰寫測試：驗證獎勵計算正確性
  - [x] 實作：`calculateRewards` 函數
  - [x] 測試通過確認：使用 `forge test`

- [x] 獎勵分發
  - [x] 撰寫測試：驗證獎勵分發流程
  - [x] 實作：`distributeRewards` 函數
  - [x] 測試通過確認：使用 `forge test`

## 3. IPFS 整合

### 3.1 模型儲存 [優先度: 高]

- [x] 更新 IPFS 連接器以支援 Foundry 輸出

  - [x] 撰寫測試：驗證連接器可正確讀取 Foundry 生成的合約地址和 ABI
  - [x] 實作：更新 `ipfs_connector.py`
  - [x] 測試通過確認：使用 Python 單元測試

- [x] 模型上傳功能

  - [x] 撰寫測試：驗證模型成功上傳到 IPFS
  - [x] 實作：優化 `upload_model` 函數
  - [x] 測試通過確認：使用小型測試模型

- [x] 模型下載功能
  - [x] 撰寫測試：驗證模型成功從 IPFS 下載
  - [x] 實作：優化 `download_model` 函數
  - [x] 測試通過確認：驗證下載模型與上傳模型一致

### 3.2 更新管理 [優先度: 中]

- [x] 更新儲存功能

  - [x] 撰寫測試：驗證模型更新成功儲存
  - [x] 實作：`store_update` 函數
  - [x] 測試通過確認：使用多個測試更新

- [x] 批次操作
  - [x] 撰寫測試：驗證批次下載與處理
  - [x] 實作：`batch_download` 函數
  - [x] 測試通過確認：使用多個更新測試批次處理

## 4. 區塊鏈連接器增強

### 4.1 Arbitrum 整合 [優先度: 高]

- [x] 更新區塊鏈連接器以支援 Foundry 輸出

  - [x] 撰寫測試：驗證連接器可正確讀取 Foundry 生成的合約地址和 ABI
  - [x] 實作：更新 `blockchain_connector.py`
  - [x] 測試通過確認：使用 Python 單元測試

- [x] Arbitrum 連接設定

  - [x] 撰寫測試：驗證成功連接到 Arbitrum 測試網
  - [x] 實作：調整連接邏輯支援 Arbitrum
  - [x] 測試通過確認：連接參數與狀態檢查

- [ ] Gas 優化
  - [ ] 撰寫測試：比較優化前後的 gas 用量
  - [ ] 實作：gas 估算和優化邏輯
  - [ ] 測試通過確認：使用 `forge gas-report`

### 4.2 交易管理 [優先度: 中]

- [x] 交易提交與監控

  - [x] 撰寫測試：驗證交易提交與確認流程
  - [x] 實作：`transaction_lifecycle` 函數
  - [x] 測試通過確認：交易狀態追蹤

- [x] 交易重試邏輯
  - [x] 撰寫測試：模擬交易失敗並驗證重試機制
  - [x] 實作：`retry_transaction` 函數
  - [x] 測試通過確認：測試不同失敗情境

### 4.3 事件處理 [優先度: 中]

- [x] 事件監聽機制

  - [x] 撰寫測試：驗證事件訂閱與接收
  - [x] 實作：`handle_events` 函數
  - [x] 測試通過確認：模擬事件觸發和處理

- [x] 事件驅動動作
  - [x] 撰寫測試：驗證特定事件觸發預期動作
  - [x] 實作：事件處理回調系統
  - [x] 測試通過確認：事件鏈反應測試

## 5. 聯邦學習核心

### 5.1 Flower 伺服器 [優先度: 高]

- [x] 更新伺服器以支援 Foundry 部署的合約

  - [x] 撰寫測試：驗證伺服器可正確連接到 Foundry 部署的合約
  - [x] 實作：更新伺服器代碼
  - [x] 測試通過確認：連接和交互測試

- [x] 任務初始化與配置

  - [x] 撰寫測試：驗證伺服器配置與任務設定
  - [x] 實作：FLServer 類別初始化
  - [x] 測試通過確認：配置參數檢查

- [x] 客戶端選擇策略
  - [x] 撰寫測試：驗證客戶端選擇邏輯
  - [x] 實作：`client_selection_strategy`
  - [x] 測試通過確認：選擇結果驗證

### 5.2 模型管理 [優先度: 高]

- [x] 全局模型處理

  - [x] 撰寫測試：驗證全局模型初始化與更新
  - [x] 實作：`manage_global_model` 函數
  - [x] 測試通過確認：模型狀態檢查

- [x] 模型聚合

  - [x] 撰寫測試：驗證不同策略下的聚合結果
  - [x] 實作：`aggregate_updates` 函數
  - [x] 測試通過確認：使用已知結果的測試案例

- [x] 模型評估
  - [x] 撰寫測試：驗證評估指標計算
  - [x] 實作：`evaluate_model` 函數
  - [x] 測試通過確認：預定義模型評估

### 5.3 Flower 客戶端 [優先度: 高]

- [x] 更新客戶端以支援 Foundry 部署的合約

  - [x] 撰寫測試：驗證客戶端可正確連接到 Foundry 部署的合約
  - [x] 實作：更新客戶端代碼
  - [x] 測試通過確認：連接和交互測試

- [x] 本地訓練邏輯

  - [x] 撰寫測試：驗證本地訓練流程與結果
  - [x] 實作：`train_locally` 函數
  - [x] 測試通過確認：使用小型測試數據集

- [x] 模型更新生成
  - [x] 撰寫測試：驗證更新格式與結構
  - [x] 實作：`generate_update` 函數
  - [x] 測試通過確認：更新結構驗證

## 6. 防禦機制整合

### 6.1 鏈下 Krum 真實實作 [優先度: 高]

- [ ] Krum 算法核心設計

  - [ ] 撰寫測試：驗證 Krum 算法的數學正確性
  - [ ] 實作：`krum_score_calculation` 函數，實現真實的距離計算與評分
  - [ ] 測試通過確認：使用已知向量與距離的測試案例

- [ ] 距離計算與優化

  - [ ] 撰寫測試：驗證不同距離計算方法的效率與準確性
  - [ ] 實作：`compute_pairwise_distances` 函數，高效計算模型更新間的距離
  - [ ] 測試通過確認：測量大規模更新的計算性能

- [ ] 鄰近更新選擇邏輯

  - [ ] 撰寫測試：驗證 n-f-2 最近鄰選擇邏輯
  - [ ] 實作：`select_nearest_neighbors` 函數
  - [ ] 測試通過確認：使用已知距離矩陣的測試案例

- [ ] 最佳更新選擇

  - [ ] 撰寫測試：驗證 Krum 選擇最佳更新的準確性
  - [ ] 實作：`select_best_update` 函數
  - [ ] 測試通過確認：多種更新分佈場景測試

- [ ] 整合 PyTorch 模型參數處理
  - [ ] 撰寫測試：驗證從 PyTorch 模型參數到 Krum 輸入的轉換
  - [ ] 實作：`process_model_updates` 函數
  - [ ] 測試通過確認：使用實際 PyTorch 模型參數

### 6.2 鏈上/鏈下 Krum 整合 [優先度: 高]

- [ ] 鏈下計算結果提交機制

  - [ ] 撰寫測試：驗證計算結果正確提交至區塊鏈
  - [ ] 實作：`submit_krum_decision` 函數
  - [ ] 測試通過確認：跟踪鏈上交易結果

- [ ] 鏈上結果確認

  - [ ] 撰寫測試：驗證鏈上合約正確接收並處理 Krum 結果
  - [ ] 實作：智能合約接收函數與事件發出
  - [ ] 測試通過確認：檢查鏈上狀態變更

- [ ] 多輪次 Krum 評估
  - [ ] 撰寫測試：模擬多輪訓練中的 Krum 選擇
  - [ ] 實作：`track_selection_history` 函數追踪選擇模式
  - [ ] 測試通過確認：多輪選擇準確性與模式分析

### 6.3 Krum 變體實驗 [優先度: 中]

- [ ] 實作 Multi-Krum

  - [ ] 撰寫測試：驗證 Multi-Krum 選擇多個貢獻者
  - [ ] 實作：`execute_multi_krum` 函數
  - [ ] 測試通過確認：使用已知結果案例

- [ ] 實作加權 Krum
  - [ ] 撰寫測試：驗證基於信譽的權重計算
  - [ ] 實作：`weighted_krum` 函數
  - [ ] 測試通過確認：信譽系統整合測試

## 7. 攻擊模擬與測試

### 7.1 惡意客戶端模擬 [優先度: 中]

- [x] 標籤翻轉攻擊

  - [x] 撰寫測試：驗證攻擊實作與效果
  - [x] 實作：LabelFlippingAttack 類別
  - [x] 測試通過確認：檢查產生的惡意更新

- [x] 模型替換攻擊

  - [x] 撰寫測試：驗證攻擊實作與效果
  - [x] 實作：ModelReplacementAttack 類別
  - [x] 測試通過確認：檢查產生的惡意更新

- [x] 拜占庭行為
  - [x] 撰寫測試：驗證不一致行為
  - [x] 實作：ByzantineClient 類別
  - [x] 測試通過確認：檢查隨機行為模式

### 7.2 攻擊成效評估 [優先度: 中]

- [x] 無防禦下的攻擊測試

  - [x] 撰寫測試：衡量攻擊對模型的影響
  - [x] 實作：`measure_attack_impact` 函數
  - [x] 測試通過確認：確認攻擊能成功影響未防禦模型

- [x] 有防禦下的攻擊測試
  - [x] 撰寫測試：衡量防禦有效性
  - [x] 實作：`measure_defense_effectiveness` 函數
  - [x] 測試通過確認：驗證防禦能抵抗攻擊

## 8. 部署與評估

### 8.1 Arbitrum 部署 [優先度: 中]

- [x] 開發部署腳本
  - [x] 撰寫測試：驗證部署流程
  - [x] 實作：`Deploy.s.sol` 腳本
  - [x] 測試通過確認：使用 `forge script`

### 8.2 性能評估 [優先度: 低]

- [ ] 系統吞吐量測試

  - [ ] 撰寫測試：衡量系統處理更新的能力
  - [ ] 實作：`throughput_test` 工具
  - [ ] 測試通過確認：不同規模下的測試

- [ ] 可擴展性評估
  - [ ] 撰寫測試：測試不同規模下系統表現
  - [ ] 實作：`scalability_evaluation` 函數
  - [ ] 測試通過確認：不同客戶端數量下的性能

### 8.3 鏈下計算與 Rollup 兼容性 [優先度: 中]

- [ ] 鏈下計算結果批次提交設計

  - [ ] 撰寫測試：驗證批次提交邏輯
  - [ ] 實作：`batch_submit_results` 函數
  - [ ] 測試通過確認：使用模擬數據測試批次處理

- [ ] Rollup 兼容性模擬測試
  - [ ] 撰寫測試：模擬在 Rollup 環境中的運行
  - [ ] 實作：`simulate_rollup_environment` 函數
  - [ ] 測試通過確認：模擬 Rollup 交互流程

## 9. 數據集與研究實驗

### 9.1 智能合約文檔 [優先度: 中]

- [x] 合約 NatSpec 文檔

  - [x] 撰寫所有公開函數的 NatSpec 註釋
  - [x] 生成合約文檔
  - [x] 驗證文檔完整性

- [x] 開發者指南
  - [x] 撰寫合約整合指南
  - [x] 記錄常見錯誤和解決方案
  - [x] 製作合約 API 參考

### 9.2 Python 代碼質量 [優先度: 中]

- [x] 代碼格式化

  - [x] 使用 Black 和 isort 格式化代碼
  - [x] 設定 pre-commit 鉤子

- [x] 類型提示與文檔

  - [x] 為所有 Python 函數添加類型提示
  - [x] 撰寫詳細的函數文檔字符串
  - [x] 生成 API 文檔

- [x] 單元測試覆蓋
  - [x] 提高單元測試覆蓋率至 80%+
  - [x] 實現模擬對象以測試外部依賴

### 9.3 數據集與攻擊實驗 [優先度: 高]

- [ ] MNIST 與 Fashion MNIST 數據處理

  - [ ] 撰寫測試：驗證數據正確加載與預處理
  - [ ] 實作：`prepare_mnist_datasets` 函數，處理兩種數據集
  - [ ] 測試通過確認：檢查數據形狀與標準化

- [ ] 聯邦學習數據分割

  - [ ] 撰寫測試：驗證 IID 與 Non-IID 分割
  - [ ] 實作：`create_federated_splits` 函數，支持多種分割策略
  - [ ] 測試通過確認：檢查分割數據的分佈特性

- [ ] 標籤翻轉攻擊數據生成 (Label Flipping)

  - [ ] 撰寫測試：驗證攻擊數據生成邏輯
  - [ ] 實作：`generate_label_flipping_attack` 函數
  - [ ] 測試通過確認：檢查生成的攻擊數據

- [ ] 模型替換攻擊 (Model Replacement)

  - [ ] 撰寫測試：驗證惡意模型生成
  - [ ] 實作：`generate_model_replacement_attack` 函數
  - [ ] 測試通過確認：比較惡意模型與標準模型

- [ ] 隨機模型攻擊 (Random Model)

  - [ ] 撰寫測試：驗證隨機性與破壞程度
  - [ ] 實作：`generate_random_model_attack` 函數
  - [ ] 測試通過確認：測量隨機模型的異常程度

- [ ] 攻擊比例實驗
  - [ ] 撰寫測試：測量不同比例攻擊者的影響
  - [ ] 實作：`evaluate_attack_ratio_impact` 函數
  - [ ] 測試通過確認：生成攻擊比例與防禦效果關係圖

### 9.4 實驗結果與研究圖表 [優先度: 高]

- [ ] 模型準確率分析

  - [ ] 撰寫測試：驗證準確率計算與記錄
  - [ ] 實作：`analyze_model_accuracy` 函數
  - [ ] 測試通過確認：比較不同場景的準確率

- [ ] 防禦效果可視化

  - [ ] 撰寫測試：生成防禦效果對比圖
  - [ ] 實作：`visualize_defense_effectiveness` 函數
  - [ ] 測試通過確認：圖表完整性與可讀性

- [ ] 收斂性分析

  - [ ] 撰寫測試：測量不同場景下的收斂速度
  - [ ] 實作：`analyze_convergence_rates` 函數
  - [ ] 測試通過確認：生成收斂曲線

- [ ] 多參數對比實驗

  - [ ] 撰寫測試：測量不同 Krum 參數設定的效果
  - [ ] 實作：`parameter_sensitivity_analysis` 函數
  - [ ] 測試通過確認：生成參數敏感度圖表

- [ ] 研究數據匯總
  - [ ] 撰寫測試：驗證數據整合與統計顯著性
  - [ ] 實作：`generate_research_summary` 函數
  - [ ] 測試通過確認：生成論文所需的數據表格

## 測試環境設置

- [x] 設置 Arbitrum Sepolia 測試網絡連接

  - [x] 取得 RPC 端點
  - [x] 配置 Foundry 以連接測試網

- [x] 設置本地 IPFS 節點

  - [x] 安裝和配置 IPFS
  - [x] 測試連接性能

- [x] 建立模擬訓練數據集
  - [x] 生成合成數據
  - [x] 製作測試用的假模型

## 依賴關係

- 開發環境設置 → 智能合約開發 → 區塊鏈連接器增強 → 部署與評估
- 智能合約基礎設施 → 任務管理 → 輪次管理 → Krum 防禦機制基礎接口
- IPFS 整合 → 聯邦學習核心
- 聯邦學習核心 → 防禦機制整合
- 惡意客戶端模擬 → 攻擊成效評估
- 鏈下 Krum 真實實作 → 鏈上/鏈下 Krum 整合 → 數據集與攻擊實驗

## 階段性交付計劃

### 階段 1 (2 週) [完成]

- [x] 完成開發環境設置
- [x] 完成智能合約基礎設施和任務管理
- [x] 完成 IPFS 模型儲存功能
- [x] 完成 Arbitrum 連接設定
- [x] 完成基本測試環境設置

### 階段 2 (2 週) [完成]

- [x] 完成輪次管理和客戶端管理
- [x] 完成 Krum 防禦機制合約接口部分
- [x] 完成區塊鏈交易和事件處理
- [x] 開始 Flower 伺服器和客戶端實作

### 階段 3 (2 週) [進行中]

- [x] 完成 Flower 伺服器和客戶端
- [x] 完成 Krum 防禦策略接口整合
- [x] 實作並測試惡意客戶端攻擊
- [x] 開始防禦效果評估
